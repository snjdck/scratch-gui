const ScriptContext = require("./ScriptContext");
const FunctionObject = require("./FunctionObject");

function apply(func){
	if(func == null)
		return;
	if(typeof func == "function")
		return func();
	return func[0](...func.slice(1));
}

class Signal
{
	constructor(){
		this.handlerMap = new Map();
	}

	add(handler, once=false){
		this.handlerMap.set(handler, once);
	}

	del(handler){
		this.handlerMap.delete(handler);
	}

	notify(...args){
		for(var handler in this.handlerMap){
			handler(...args);
			if(this.handlerMap[handler]){
				this.delete(handler);
			}
		}
	}
}

class Thread
{
	constructor(virtualMachine, codeList, globalContext){
		this.virtualMachine = virtualMachine;
		this.codeList = codeList;
		this.globalContext = globalContext;
		this.context = this.createContext();

		this.ip = 0;
		this.valueStack = [];
		this.sp = -1;

		this.invokeStack = [];
		this._isSuspend = false;
		this.suspendUpdater = null;

		this._finishSignal = new Signal();
		this._finishFlag = false;
		this._interruptFlag = false;
		this.runFlag = 0;
		this.userData = null;
	}
	
	createContext(){
		return this.globalContext != null ? this.globalContext.createChild() : new ScriptContext();
	}
	
	get finishSignal(){
		return this._finishSignal;
	}
	
	notifyFinish(){
		this._finishSignal.notify(this._interruptFlag);
	}
	
	interrupt(){
		this._interruptFlag = true;
		this._finishFlag = true;
	}
	
	isFinish(){
		return this._finishFlag;
	}
	
	start(){
		this.virtualMachine.startThread(this);
	}
	
	restart(){
		this.runFlag = 0;
		this._finishFlag = this._interruptFlag = false;
		this.valueStack.length = this.ip = 0;
		this.invokeStack.length = 0;
		this.sp = -1;
		this.context = this.createContext();
		this.resume();
		this.start();
	}
	
	execNextCode(instructionExcetor){
		const {ip, codeList} = this;
		if(ip < codeList.length){
			instructionExcetor.execute(codeList[ip], codeList[ip+1]);
		}else{
			this._finishFlag = true;
		}
	}
	
	yield(waitFlag=true){
		this.virtualMachine.yieldFlag = true;
		if(!this.virtualMachine.waitFlag && waitFlag){
			this.virtualMachine.waitFlag = true;
		}
	}
	
	suspend(){
		this._isSuspend = true;
	}
	
	resume(){
		this._isSuspend = false;
		this.suspendUpdater = null;
	}
	
	isSuspend(){
		return this._isSuspend;
	}
	
	push(value){
		this.valueStack[++this.sp] = value;
	}
	
	pop(){
		return this.valueStack[this.sp--];
	}
	
	peek(){
		return this.valueStack[this.sp];
	}
	
	put(value){
		this.valueStack[this.sp] = value;
	}
	
	updateSuspendState(){
		if(this.suspendUpdater != null)
			apply(this.suspendUpdater);
	}
	
	get resultValue(){
		if(this._interruptFlag)
			return;
		if(this._finishFlag && this.sp == 0)
			return this.valueStack[0];
	}
	
	requestRedraw(){
		if(Thread.REDRAW_FLAG){
			this.virtualMachine.redrawFlag = true;
		}
	}
	
	isRecursiveInvoke(funcRef){
		for(var scope of this.invokeStack){
			if(scope.hasInvoked(funcRef)){
				return true;
			}
		}
		return false;
	}
	/*
	overrideScope(scope)
	{
		var index = invokeStack.length - 1;
		scope.join(invokeStack[index]);
		invokeStack[index] = scope;
	}
	//*/
	peekScope(){
		return this.invokeStack[this.invokeStack.length-1];
	}
	
	pushScope(scope){
		this.invokeStack.push(scope);
	}
	
	popScope(){
		return this.invokeStack.pop();
	}
	
	clone(){
		return new Thread(this.virtualMachine, this.codeList, this.globalContext);
	}
	
	newVar(varName, varValue){
		this.context.newKey(varName, varValue);
	}
	
	getVar(varName){
		return this.context.getValue(varName);
	}
	
	setVar(varName, value){
		this.context.setValue(varName, value);
	}
	
	newFunction(argList, addressEnd, userData){
		return new FunctionObject(this.codeList, this.context, argList, this.ip, addressEnd, userData);
	}
}

Thread.EXEC_TIME = 0;
Thread.REDRAW_FLAG = true;
Thread.Current = null;

module.exports = Thread;