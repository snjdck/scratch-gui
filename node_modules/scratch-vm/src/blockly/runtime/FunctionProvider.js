const ScriptContext = require("./ScriptContext");

const isArray = value => Object.prototype.toString.apply(value) == "[object Array]";
const isAsync = value => value && (value.toString() == "[object Promise]") && (typeof value.then == "function");

class FunctionProvider
{
	constructor(){
		this.context = new ScriptContext();
	}
	
	register(name, handler){
		this.context.newKey(name, handler);
	}
	
	alias(name, newName){
		console.assert(this.context.hasKey(name, false));
		this.context.newKey(newName, this.context.getValue(name));
	}
	
	execute(thread, name, argList, retCount){
		const context = this.context;
		if(context.hasKey(name, false)){
			var handler = context.getValue(name);
			FunctionProvider.CallFunction(thread, handler, argList, retCount > 0);
		}else{
			thread.requestCheckStack(retCount);
			this.onCallUnregisteredFunction(name, argList, retCount);
			if(!thread.isSuspend()){
				thread.checkStack();
			}
		}
	}
	
	onCallUnregisteredFunction(name, argList, retCount){
		console.log("interpreter invoke method:", name, argList, retCount);
	}
	
	static async CallFunction(thread, handler, valueList, hasValue){
		const value = isArray(valueList) ? handler.apply(thread, valueList) : handler.call(thread, valueList);
		if(isAsync(value)){
			thread.suspend();
			var result = await value;
			if(hasValue)
				thread.push(result);
			thread.resume();
		}else if(hasValue){
			thread.push(value);
		}
	}
}

module.exports = FunctionProvider;