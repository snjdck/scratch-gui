const OpCode = require("../OpCode");
const OpFactory = require("../OpFactory");

var loopLayer = 0;

function append(target, list){
	target.push(...list);
}
	
function translate(blockList)
{
	console.assert(loopLayer == 0);
	return genStatementCode(blockList);
}

function genStatementCode(blockList)
{
	var result = [];
	var n = blockList != null ? blockList.length : 0;
	for(var i=0; i<n; ++i){
		var block = blockList[i];
		switch(block["type"]){
			case "break":
				if(loopLayer > 0){
					result.push([OpCode.BREAK]);
				}
				break;
			case "continue":
				if(loopLayer > 0){
					result.push([OpCode.CONTINUE]);
				}
				break;
			case "function":
				append(result, genFunctionCode(block));
				break;
			case "while":
			case "for":
				append(result, genForCode(block));
				break;
			case "until":
				append(result, genUntilCode(block));
				break;
			case "if":
				append(result, genIfCode(blockList, i));
				break;
			case "unless":
				append(result, genUnlessCode(block));
				break;
			case "loop":
				append(result, genLoopTimesCode(block));
				break;
			case "invoke":
				append(result, genInvokeCode(block));
				break;
			case "return":
				result.push(OpFactory.Return(0));
				break;
			case "newVar":
				append(result, genExpressionCode(block["value"]));
				result.push([OpCode.NEW_VAR, block["name"]]);
				break;
			case "setVar":
				append(result, genExpressionCode(block["value"]));
				result.push([OpCode.SET_VAR, block["name"]]);
				break;
		}
	}
	return result;
}

function genExpressionCode(block)
{
	switch(block["type"]){
		case "string":
		case "number":
			return [OpFactory.Push(block["value"])];
		case "function":
			return genFunctionCode(block);
		case "invoke":
			return genInvokeCode(block);
		case "getVar":
			return [OpFactory.GetVar(block["name"])];
		case "newFunction":
			return genNewFunctionCode(block);
	}
	return null;
}

function genArgListCode(argList)
{
	var n = argList != null ? argList.length : 0;
	var result = [];
	for(var i=0; i<n; ++i){
		append(result, genExpressionCode(argList[i]));
	}
	return result;
}

function genFunctionCode(block)
{
	var argList = block["argList"];
	if(!Array.isArray(argList)){
		var argDict = argList;
		var argName = [];
		argList = [];
		for(let key in argDict){
			argList.push(argDict[key]);
			argName.push(key);
		}
	}
	
	var result = genArgListCode(argList);
	result.push(OpFactory.Call(block["method"], argList.length, block["retCount"], argName));
	return result;
}

function genForCode(block)
{
	return genForCodeImpl(
		genStatementCode(block["init"]),
		genExpressionCode(block["condition"]),
		genStatementCode(block["iter"]),
		block["code"]
	);
}

function genUntilCode(block)
{
	++loopLayer;
	var loopCode = genStatementCode(block["code"]);
	--loopLayer;
	replaceBreakContinue(loopCode, loopCode.length + 1);
	
	var result = genExpressionCode(block["condition"]);
	result.push(OpFactory.JumpIfFalse(2));
	result.push(OpFactory.Jump(loopCode.length + 2));
	append(result, loopCode);
	result.push(OpFactory.Jump(-result.length));
	return result;
}

function genForCodeImpl(initCode, conditionCode, iterCode, loopBlock)
{
	++loopLayer;
	var loopCode = genStatementCode(loopBlock);
	--loopLayer;
	
	var result = initCode;
	
	var loopCount = loopCode.length + iterCode.length;
	var totalCount = loopCount + conditionCode.length;
	
	replaceBreakContinue(loopCode, loopCount + 1);
	
	append(result, conditionCode);
	result.push(OpFactory.JumpIfFalse(loopCount + 2));
	append(result, loopCode);
	append(result, iterCode);
	result.push(OpFactory.Jump(-(totalCount + 1)));
	/*
	replaceBreakContinue(loopCode, totalCount + 1);
	
	result.push(OpFactory.Jump(loopCount + 1));
	append(result, loopCode);
	append(result, iterCode);
	append(result, conditionCode);
	result.push(OpFactory.JumpIfTrue(-totalCount));
	//*/
	return result;
}

function replaceBreakContinue(codeList, totalCodeLength)
{
	for(var i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case OpCode.BREAK:
				codeList[i] = OpFactory.Jump(totalCodeLength - i);
				break;
			case OpCode.CONTINUE:
				codeList[i] = OpFactory.Jump(n - i);
				break;
		}
	}
}

function genIfCodeImpl(condition, caseTrue, caseFalse)
{
	var result = genExpressionCode(condition);
	
	result.push(OpFactory.JumpIfFalse(caseTrue.length + 2));
	append(result, caseTrue);
	result.push(OpFactory.Jump(caseFalse.length + 1));
	append(result, caseFalse);
	
	return result;
}

function genIfCode(blockList, index)
{
	var block = blockList[index];
	return genIfCodeImpl(block["condition"], genStatementCode(block["code"]), genElseCode(blockList, index + 1));
}

function genElseCode(blockList, index)
{
	if(index < blockList.length){
		var block = blockList[index];
		switch(block["type"]){
			case "else if":
				return genIfCode(blockList, index);
			case "else":
				return genStatementCode(block["code"]);
		}
	}
	return [];
}

function genUnlessCode(block)
{
	return genIfCodeImpl(block["condition"], [], genStatementCode(block["code"]));
}

function genLoopTimesCode(block)
{
	++loopLayer;
	var loopCode = genStatementCode(block["code"]);
	--loopLayer;
	replaceBreakContinue(loopCode, loopCode.length + 1);
	return [
		...genExpressionCode(block["count"]),
		OpFactory.Jump(loopCode.length + 1),
		...loopCode,
		OpFactory.JumpIfPositive(-loopCode.length),
		OpFactory.Pop()
	];
}

function genInvokeCode(block)
{
	var argList = block["argList"];
	var result = genExpressionCode(block["target"]);
	append(result, genArgListCode(argList));
	result.push(OpFactory.Invoke(argList.length, block["retCount"]));
	return result;
}

function genNewFunctionCode(block)
{
	var result = genStatementCode(block["code"]);
	result.push(OpFactory.Return(0));
	result.unshift(OpFactory.NewFunction(result.length+1, block["argList"], block["userData"]));
	return result;
}

exports.translate = translate;