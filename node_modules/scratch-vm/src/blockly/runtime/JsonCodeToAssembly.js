const OpCode = require("../OpCode");
const OpFactory = require("../OpFactory");

var loopLayer = 0;

function append(target, list){
	target.push(...list);
}
	
function translate(blockList)
{
	console.assert(loopLayer == 0);
	return genStatementCode(blockList);
}

function genStatementCode(blockList)
{
	var result = [];
	var n = blockList != null ? blockList.length : 0;
	for(var i=0; i<n; ++i){
		var block = blockList[i];
		switch(block["type"]){
			case "break":
				if(loopLayer > 0){
					result.push([OpCode.BREAK]);
				}
				break;
			case "continue":
				if(loopLayer > 0){
					result.push([OpCode.CONTINUE]);
				}
				break;
			case "function":
				append(result, genFunctionCode(block));
				break;
			case "while":
			case "for":
				append(result, genForCode(block));
				break;
			case "until":
				append(result, genUntilCode(block));
				break;
			case "if":
				append(result, genIfCode(blockList, i));
				break;
			case "unless":
				append(result, genUnlessCode(block));
				break;
			case "loop":
				append(result, genLoopTimesCode(block));
				break;
			case "invoke":
				append(result, genInvokeCode(block));
				break;
			case "return":
				result.push(OpFactory.Return(0));
				break;
			case "newVar":
				append(result, genExpressionCode(block["value"]));
				result.push([OpCode.NEW_VAR, block["name"]]);
				break;
			case "setVar":
				append(result, genExpressionCode(block["value"]));
				result.push([OpCode.SET_VAR, block["name"]]);
				break;
		}
	}
	return result;
}

function genExpressionCode(block)
{
	switch(block["type"]){
		case "string":
		case "number":
			return [OpFactory.Push(block["value"])];
		case "function":
			return genFunctionCode(block);
		case "invoke":
			return genInvokeCode(block);
		case "getVar":
			return [OpFactory.GetVar(block["name"])];
		case "newFunction":
			return genNewFunctionCode(block);
	}
	return null;
}

function genArgListCode(argList)
{
	if(argList == null)
		return [];
	return argList.map(arg => genExpressionCode(arg)).reduce((a, b) => a.concat(b), []);
}

function genFunctionCode({method, argList, retCount})
{
	if(!Array.isArray(argList)){
		var argDict = argList;
		var argName = [];
		argList = [];
		for(let key in argDict){
			argList.push(argDict[key]);
			argName.push(key);
		}
	}
	
	return [
		...genArgListCode(argList),
		OpFactory.Call(method, argList.length, retCount, argName)
	];
}

function genForCode({init, condition, iter, code})
{
	return genForCodeImpl(
		genStatementCode(init),
		genExpressionCode(condition),
		genStatementCode(iter),
		code
	);
}

function genUntilCode(block)
{
	++loopLayer;
	var loopCode = genStatementCode(block["code"]);
	--loopLayer;
	replaceBreakContinue(loopCode, loopCode.length + 1);
	
	var result = genExpressionCode(block["condition"]);
	result.push(OpFactory.JumpIfFalse(2));
	result.push(OpFactory.Jump(loopCode.length + 2));
	append(result, loopCode);
	result.push(OpFactory.Jump(-result.length));
	return result;
}

function genForCodeImpl(initCode, conditionCode, iterCode, loopBlock)
{
	++loopLayer;
	var loopCode = genStatementCode(loopBlock);
	--loopLayer;
	
	var result = initCode;
	
	var loopCount = loopCode.length + iterCode.length;
	var totalCount = loopCount + conditionCode.length;
	
	replaceBreakContinue(loopCode, loopCount + 1);
	
	append(result, conditionCode);
	result.push(OpFactory.JumpIfFalse(loopCount + 2));
	append(result, loopCode);
	append(result, iterCode);
	result.push(OpFactory.Jump(-(totalCount + 1)));
	/*
	replaceBreakContinue(loopCode, totalCount + 1);
	
	result.push(OpFactory.Jump(loopCount + 1));
	append(result, loopCode);
	append(result, iterCode);
	append(result, conditionCode);
	result.push(OpFactory.JumpIfTrue(-totalCount));
	//*/
	return result;
}

function replaceBreakContinue(codeList, totalCodeLength)
{
	for(var i=0, n=codeList.length; i<n; ++i){
		switch(codeList[i][0]){
			case OpCode.BREAK:
				codeList[i] = OpFactory.Jump(totalCodeLength - i);
				break;
			case OpCode.CONTINUE:
				codeList[i] = OpFactory.Jump(n - i);
				break;
		}
	}
}

function genIfCodeImpl(condition, caseTrue, caseFalse)
{
	return [
		...genExpressionCode(condition),
		OpFactory.JumpIfFalse(caseTrue.length + 2),
		...caseTrue,
		OpFactory.Jump(caseFalse.length + 1),
		...caseFalse
	];
}

function genIfCode(blockList, index)
{
	const {condition, code} = blockList[index];
	return genIfCodeImpl(condition, genStatementCode(code), genElseCode(blockList, index + 1));
}

function genElseCode(blockList, index)
{
	if(index < blockList.length){
		const {type, code} = blockList[index];
		switch(type){
			case "else if":
				return genIfCode(blockList, index);
			case "else":
				return genStatementCode(code);
		}
	}
	return [];
}

function genUnlessCode({condition, code})
{
	return genIfCodeImpl(condition, [], genStatementCode(code));
}

function genLoopTimesCode({count, code})
{
	++loopLayer;
	const loopCode = genStatementCode(code);
	--loopLayer;
	replaceBreakContinue(loopCode, loopCode.length + 1);
	return [
		...genExpressionCode(count),
		OpFactory.Jump(loopCode.length + 1),
		...loopCode,
		OpFactory.JumpIfPositive(-loopCode.length),
		OpFactory.Pop()
	];
}

function genInvokeCode({target, argList, retCount})
{
	return [
		...genExpressionCode(target),
		...genArgListCode(argList),
		OpFactory.Invoke(argList.length, retCount)
	];
}

function genNewFunctionCode({code, argList, userData})
{
	const result = genStatementCode(code);
	return [
		OpFactory.NewFunction(result.length+2, argList, userData),
		...result,
		OpFactory.Return(0)
	];
}

exports.translate = translate;