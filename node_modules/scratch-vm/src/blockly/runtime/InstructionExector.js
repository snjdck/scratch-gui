const OpCode = require("../OpCode");
const Thread = require("./Thread");
const FunctionScope = require("./FunctionScope");

class InstructionExector
{
	constructor(functionProvider){
		this.functionProvider = functionProvider;
		this.opDict = {};
		this.argList = [];

		this.regOpHandler(OpCode.CALL, this.__onCall.bind(this));
		this.regOpHandler(OpCode.PUSH, this.__onPush.bind(this));
		this.regOpHandler(OpCode.JUMP, this.__onJump.bind(this));
		this.regOpHandler(OpCode.JUMP_IF_FALSE, this.__onJumpIfFalse.bind(this));
		this.regOpHandler(OpCode.INVOKE, this.__onInvoke.bind(this));
		this.regOpHandler(OpCode.RETURN, this.__onReturn.bind(this));
		this.regOpHandler(OpCode.JUMP_IF_NOT_POSITIVE, this.__onJumpIfNotPositive.bind(this));
		this.regOpHandler(OpCode.NEW_VAR, this.__onNewVar.bind(this));
		this.regOpHandler(OpCode.GET_VAR, this.__onGetVar.bind(this));
		this.regOpHandler(OpCode.SET_VAR, this.__onSetVar.bind(this));
		this.regOpHandler(OpCode.NEW_FUNCTION, this.__onNewFunction.bind(this));
	}
	
	regOpHandler(op, handler){
		this.opDict[op] = handler;
	}
	
	execute(instruction, nextInstruction){
		this.nextOp = nextInstruction && nextInstruction[0];
		this.nextData = nextInstruction;
		var handler = this.opDict[instruction[0]];
		handler.apply(null, instruction);
	}
	
	__onCall(op, argCount, retCount, method, argNames, params){
		var thread = Thread.Current;
		this.getArgList(thread, argCount);
		var paramList = this.getParamList(params);
		if(argNames != null){
			var argDict = {};
			for(let i=0, n=paramList.length; i<n; ++i){
				argDict[argNames[i]] = paramList[i];
			}
		}
		this.functionProvider.execute(thread, method, argDict || paramList, retCount);
		++thread.ip;
	}
	
	__onPush(op, value){
		var thread = Thread.Current;
		thread.push(value);
		++thread.ip;
	}
	
	__onJump(op, count){
		var thread = Thread.Current;
		thread.ip += count;
		if(count < 0) thread.yield(false);
		else if(count == 0) thread.suspend();
	}
	
	__onJumpIfFalse(op, count){
		var thread = Thread.Current;
		if(thread.pop()){
			count = (nextOp == OpCode.JUMP) ? (nextData[1] + 1) : 1;
		}
		if(count < 0){
			thread.yield(false);
		}
		thread.ip += count;
	}
	
	__onJumpIfNotPositive(op, count){
		var thread = Thread.Current;
		var value = thread.peek();
		if(value <= 0){
			thread.pop();
			thread.ip += count;
		}else{
			thread.put(value - 1);
			++thread.ip;
		}
	}
	
	__onInvoke(op, argCount, retCount, params=null){
		var thread = Thread.Current;
		this.getArgList(thread, argCount);
		var funcRef = thread.pop();
		var scope = new FunctionScope(funcRef);
		funcRef.initScope(scope, this.getParamList(params));
		scope.doInvoke(thread);
		if(thread.isRecursiveInvoke(funcRef)){
			thread.yield(false);
		}
		if(nextOp == OpCode.RETURN && retCount == nextData[1]){
			var prevScope = thread.peekScope();
			if(retCount == prevScope.retCount){
				scope.join(thread.popScope());
			}
		}
		thread.pushScope(scope);
		scope.retCount = retCount;
	}
	
	__onReturn(op, retCount){
		var thread = Thread.Current;
		var scope = thread.popScope();
		scope.onReturn(thread);
		if(retCount == scope.retCount){
			return;
		}
		if(retCount > scope.retCount){
			while(retCount-- != scope.retCount){
				thread.pop();
			}
		}else{
			while(retCount++ != scope.retCount){
				thread.push(null);
			}
		}
	}
	
	__onNewVar(op, varName){
		var thread = Thread.Current;
		thread.newVar(varName, thread.pop());
		++thread.ip;
	}
	
	__onGetVar(op, varName){
		var thread = Thread.Current;
		thread.push(thread.getVar(varName));
		++thread.ip;
	}
	
	__onSetVar(op, varName){
		var thread = Thread.Current;
		thread.setVar(varName, thread.pop());
		++thread.ip;
	}
	
	__onNewFunction(op, offset, argList, userData){
		var thread = Thread.Current;
		var addressEnd = thread.ip + offset;
		thread.push(thread.newFunction(argList, addressEnd, userData));
		thread.ip = addressEnd;
	}
	
	getArgList(thread, argCount){
		this.argList.length = argCount;
		while(argCount-- > 0)
			this.argList[argCount] = thread.pop();
	}
	
	getParamList(info){
		if(info == null){
			return this.argList;
		}
		var paramList = info[0];
		var indexList = info[1];
		for(var i=indexList.length-1; i>=0; --i){
			paramList[indexList[i]] = this.argList[i];
		}
		return paramList;
	}
}

module.exports = InstructionExector;