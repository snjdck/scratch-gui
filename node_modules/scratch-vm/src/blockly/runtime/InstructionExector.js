const OpCode = require("../OpCode");
const Thread = require("./Thread");
const FunctionScope = require("./FunctionScope");

class InstructionExector
{
	constructor(functionProvider){
		this.functionProvider = functionProvider;
		this.opDict = {};

		this.regOpHandler(OpCode.CALL, onCall);
		this.regOpHandler(OpCode.PUSH, onPush);
		this.regOpHandler(OpCode.POP, onPop);
		this.regOpHandler(OpCode.JUMP, onJump);
		this.regOpHandler(OpCode.JUMP_IF_FALSE, onJumpIfFalse);
		this.regOpHandler(OpCode.INVOKE, onInvoke);
		this.regOpHandler(OpCode.RETURN, onReturn);
		this.regOpHandler(OpCode.JUMP_IF_POSITIVE, onJumpIfPositive);
		this.regOpHandler(OpCode.NEW_VAR, onNewVar);
		this.regOpHandler(OpCode.GET_VAR, onGetVar);
		this.regOpHandler(OpCode.SET_VAR, onSetVar);
		this.regOpHandler(OpCode.NEW_FUNCTION, onNewFunction);
	}
	
	regOpHandler(op, handler){
		this.opDict[op] = handler;
	}
	
	execute(instruction, nextInstruction){
		this.nextOp = nextInstruction && nextInstruction[0];
		this.nextData = nextInstruction;
		var handler = this.opDict[instruction[0]];
		handler.apply(this, instruction);
	}
}

function onCall(op, argCount, retCount, method, argNames, paramInfo){
	var thread = Thread.Current;
	var argList = collectArgList(thread, argCount, paramInfo);
	if(argNames != null){
		var argDict = {};
		for(let i=0, n=argList.length; i<n; ++i){
			argDict[argNames[i]] = argList[i];
		}
	}
	this.functionProvider.execute(thread, method, argDict || argList, retCount);
	++thread.ip;
}

function onPush(op, value){
	var thread = Thread.Current;
	thread.push(value);
	++thread.ip;
}

function onPop(op){
	var thread = Thread.Current;
	thread.pop();
	++thread.ip;
}

function onJump(op, count){
	var thread = Thread.Current;
	thread.ip += count;
	if(count < 0) thread.yield(false);
	else if(count == 0) thread.suspend();
}

function onJumpIfFalse(op, count){
	const {nextOp, nextData} = this;
	var thread = Thread.Current;
	if(thread.pop()){
		count = (nextOp == OpCode.JUMP) ? (nextData[1] + 1) : 1;
	}
	if(count < 0){
		thread.yield(false);
	}
	thread.ip += count;
}

function onJumpIfPositive(op, count){
	var thread = Thread.Current;
	var value = thread.peek();
	if(value >= 1){
		thread.put(value - 1);
		thread.ip += count;
	}else{
		++thread.ip;
	}
}

function onInvoke(op, argCount, retCount, paramInfo){
	var thread = Thread.Current;
	var argList = collectArgList(thread, argCount, paramInfo);
	var funcRef = thread.pop();
	var scope = new FunctionScope(funcRef);
	funcRef.initScope(scope, argList);
	scope.doInvoke(thread);
	if(thread.isRecursiveInvoke(funcRef)){
		thread.yield(false);
	}
	if(nextOp == OpCode.RETURN && retCount == nextData[1]){
		var prevScope = thread.peekScope();
		if(retCount == prevScope.retCount){
			scope.join(thread.popScope());
		}
	}
	thread.pushScope(scope);
	scope.retCount = retCount;
}

function onReturn(op, retCount){
	var thread = Thread.Current;
	var scope = thread.popScope();
	scope.onReturn(thread);
	if(retCount == scope.retCount){
		return;
	}
	if(retCount > scope.retCount){
		while(retCount-- != scope.retCount){
			thread.pop();
		}
	}else{
		while(retCount++ != scope.retCount){
			thread.push(null);
		}
	}
}

function onNewVar(op, varName){
	var thread = Thread.Current;
	thread.newVar(varName, thread.pop());
	++thread.ip;
}

function onGetVar(op, varName){
	var thread = Thread.Current;
	thread.push(thread.getVar(varName));
	++thread.ip;
}

function onSetVar(op, varName){
	var thread = Thread.Current;
	thread.setVar(varName, thread.pop());
	++thread.ip;
}

function onNewFunction(op, offset, argList, userData){
	var thread = Thread.Current;
	var addressEnd = thread.ip + offset;
	thread.push(thread.newFunction(argList, addressEnd, userData));
	thread.ip = addressEnd;
}

const collectArgList = (argList => (thread, argCount, paramInfo) => {
	argList.length = argCount;
	while(argCount-- > 0)
		argList[argCount] = thread.pop();
	if(paramInfo == null)
		return argList;
	const [paramList, indexList] = paramInfo;
	for(var i=indexList.length-1; i>=0; --i)
		paramList[indexList[i]] = argList[i];
	return paramList;
})([]);

module.exports = InstructionExector;