const {Interpreter,FunctionProvider, Thread} = require("../blockly");

class ScratchFunctionProvider extends FunctionProvider
{
    constructor(runtime){
        super();
        this.runtime = runtime;
    }

    onCallUnregisteredFunction(name, argList, retCount){
        const {runtime} = this;
        const thread = Thread.Current;
        const util = {
            target: thread.userData.target,
            yield: function () {
                thread.yield();
            },
            stopAll: function () {
                runtime.stopAll();
            },
            stopOtherTargetThreads: function () {
                runtime.stopForTarget(target, thread);
            },
            stopThisScript: function () {
                thread.interrupt();
            },
            startHats: function (requestedHat, optMatchFields, optTarget) {
                return runtime.startHats(requestedHat, optMatchFields, optTarget);
            },
            ioQuery: function (device, func, args) {
                // Find the I/O device and execute the query/function call.
                if (runtime.ioDevices[device] && runtime.ioDevices[device][func]) {
                    const devObject = runtime.ioDevices[device];
                    return devObject[func].apply(devObject, args);
                }
            }
        };
        
        var handler = runtime.getOpcodeFunction(name);
        FunctionProvider.CallFunction(thread, handler, [argList, util], retCount > 0);
        //console.log("interpreter invoke method:", name, argList, retCount);
    }
}

module.exports = runtime => new Interpreter(new ScratchFunctionProvider(runtime));