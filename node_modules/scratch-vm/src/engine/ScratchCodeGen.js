const SyntaxTreeFactory = require("../blockly/SyntaxTreeFactory");

function genCode(runtime, target, id){
    var result = [];
    while(id != null){
        var blockContainer = target.blocks;
        var block = blockContainer.getBlock(id);
        if(block == null){
            blockContainer = runtime.flyoutBlocks;
            block = blockContainer.getBlock(id);
        }
        const opcode = blockContainer.getOpcode(block);
        if(!runtime.getIsHat(opcode)){
            result.push(...genCodeTree(runtime, target, id));
        }
        id = blockContainer.getNextBlock(id);
    }
    return result;
}

function genCodeTree(runtime, target, id){
    var blockContainer = target.blocks;
    var block = blockContainer.getBlock(id);
    if(block == null){
        blockContainer = runtime.flyoutBlocks;
        block = blockContainer.getBlock(id);
    }
    
    const opcode = blockContainer.getOpcode(block);
    const fields = blockContainer.getFields(block);
    const inputs = blockContainer.getInputs(block);
    const blockFunction = runtime.getOpcodeFunction(opcode);
    //const isHat = this.getIsHat(opcode);

    if(blockFunction == null && fields){
        let keys = Object.keys(fields);
        if (keys.length === 1 && Object.keys(inputs).length === 0) {
            // One field and no inputs - treat as arg.
            let item = fields[keys[0]];
            if(item.name == "NUM"){
                return [SyntaxTreeFactory.NewNumber(Number(item.value))];
            }
            return [SyntaxTreeFactory.NewString(item.value)];
        } else {
            console.warn(`Could not get implementation for opcode: ${opcode}`);
            return;
        }
    }

    
    var argValues = {};

    for(let key in fields){
        let field = fields[key];
        if(field.block)
            argValues[key] = genCodeTree(runtime, target, field.block)[0];
    }
    for(let key in inputs){
        let input = inputs[key];
        if(input.block)
            argValues[key] = genCodeTree(runtime, target, input.block)[0];
    }
    
    if(opcode == "control_if"){
        var subCodes = genCode(runtime, target, target.blocks.getBranch(id, 1));
        return [SyntaxTreeFactory.NewIf(argValues["CONDITION"] || SyntaxTreeFactory.NewNumber(0), subCodes)];
    }
    if(opcode == "control_if_else"){
        var subCodes1 = genCode(runtime, target, target.blocks.getBranch(id, 1));
        var subCodes2 = genCode(runtime, target, target.blocks.getBranch(id, 2));
        return [
            SyntaxTreeFactory.NewIf(argValues["CONDITION"] || SyntaxTreeFactory.NewNumber(0), subCodes1),
            SyntaxTreeFactory.NewElse(subCodes2)
        ];
    }
    if(opcode == "control_wait_until"){
        return [SyntaxTreeFactory.NewUntil(argValues["CONDITION"] || SyntaxTreeFactory.NewNumber(1))];
    }
    if(opcode == "control_repeat_until"){
        var subCodes = genCode(runtime, target, target.blocks.getBranch(id, 1));
        return [SyntaxTreeFactory.NewUntil(argValues["CONDITION"] || SyntaxTreeFactory.NewNumber(1), subCodes)];
    }
    if(opcode == "control_repeat"){
        var subCodes = genCode(runtime, target, target.blocks.getBranch(id, 1));
        return [SyntaxTreeFactory.NewLoop(argValues["TIMES"] || SyntaxTreeFactory.NewNumber(0), subCodes)];
    }
    if(opcode == "control_forever"){
        var subCodes = genCode(runtime, target, target.blocks.getBranch(id, 1));
        return [SyntaxTreeFactory.NewWhile(SyntaxTreeFactory.NewNumber(1), subCodes)];
    }
    return [SyntaxTreeFactory.Call(opcode, argValues, 0)];
}

module.exports = genCode;