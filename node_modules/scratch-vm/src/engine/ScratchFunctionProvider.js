const Cast = require('../util/cast');
const {FunctionProvider, Thread} = require("../blockly");

function control_wait({DURATION}){
	const seconds = Cast.toNumber(DURATION);
	const timeout = performance.now() + seconds * 1000;
	return new Promise(resolve => {
		this.suspendUpdater = () => {
			if(performance.now() >= timeout){
				resolve();
			}
		};
	});
}

function control_stop({STOP_OPTION}){
	const {runtime, target} = this.userData;
	switch(STOP_OPTION){
	case 'all':
		runtime.stopAll();
		break;
	case 'other scripts in sprite':
	case 'other scripts in stage':
		runtime.stopForTarget(target, this);
		break;
	case 'this script':
		this.interrupt();
		break;
	}
}

function control_create_clone_of({CLONE_OPTION}){
	const {runtime, target} = this.userData;
	let cloneTarget;
	if(CLONE_OPTION === '_myself_'){
		cloneTarget = target;
	}else{
		cloneTarget = runtime.getSpriteTargetByName(CLONE_OPTION);
	}
	if(!cloneTarget){
		return;
	}
	const newClone = cloneTarget.makeClone();
	if(newClone){
		runtime.targets.push(newClone);
	}
}

function control_delete_this_clone(){
	const {runtime, target} = this.userData;
	if(target.isOriginal)
		return;
	runtime.disposeTarget(target);
	runtime.stopForTarget(target);
}

class ScratchFunctionProvider extends FunctionProvider
{
	constructor(runtime){
		super();
		this.runtime = runtime;
		this.register(control_wait);
		this.register(control_stop);
		this.register(control_create_clone_of);
		this.register(control_delete_this_clone);
	}

	onCallUnregisteredFunction(name, argList, retCount){
		const {runtime} = this;
		const thread = Thread.Current;
		const util = {
			target: thread.userData.target,
			yield: function () {
				thread.yield();
			},
			startHats: function (requestedHat, optMatchFields, optTarget) {
				return runtime.startHats(requestedHat, optMatchFields, optTarget);
			},
			ioQuery: function (device, func, args) {
				// Find the I/O device and execute the query/function call.
				if (runtime.ioDevices[device] && runtime.ioDevices[device][func]) {
					const devObject = runtime.ioDevices[device];
					return devObject[func].apply(devObject, args);
				}
			}
		};
		
		var handler = runtime.getOpcodeFunction(name);
		FunctionProvider.CallFunction(thread, handler, [argList, util], retCount > 0);
		//console.log("interpreter invoke method:", name, argList, retCount);
	}
}

module.exports = ScratchFunctionProvider;