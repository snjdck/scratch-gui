const MathUtil = require('../util/math-util');
const Cast = require('../util/cast');
const Clone = require('../util/clone');

/**
 * The key to load & store a target's sound-related state.
 * @type {string}
 */
const STATE_KEY = 'Scratch.sound';

/**
 * The default sound-related state, to be used when a target has no existing sound state.
 * @type {SoundState}
 */
const DEFAULT_SOUND_STATE = {
	volume: 100,
	currentInstrument: 0,
	effects: {
		pitch: 0,
		pan: 0
	}
};

/**
 * The minimum and maximum MIDI note numbers, for clamping the input to play note.
 * @type {{min: number, max: number}}
 */
const MIDI_NOTE_RANGE = {min: 36, max: 96}; // C2 to C7

/**
 * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
 * 100 beats at the default tempo of 60bpm is 100 seconds.
 * @type {{min: number, max: number}}
 */
const BEAT_RANGE = {min: 0, max: 100};

/** The minimum and maximum tempo values, in bpm.
 * @type {{min: number, max: number}}
 */
const TEMPO_RANGE = {min: 20, max: 500};

/** The minimum and maximum values for each sound effect.
 * @type {{effect:{min: number, max: number}}}
 */
const EFFECT_RANGE = {
	pitch: {min: -600, max: 600}, // -5 to 5 octaves
	pan: {min: -100, max: 100} // 100% left to 100% right
};

/**
 * @param {Target} target - collect sound state for this target.
 * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.
 * @private
 */
function _getSoundState(target){
	let soundState = target.getCustomState(STATE_KEY);
	if(!soundState){
		soundState = Clone.simple(DEFAULT_SOUND_STATE);
		target.setCustomState(STATE_KEY, soundState);
	}
	return soundState;
}


function sound_play({SOUND_MENU}){
	const {runtime, target} = this.userData;
	const index = _getSoundIndex.call(this, SOUND_MENU);
	if(index >= 0){
		const soundId = target.sprite.sounds[index].soundId;
		if(target.audioPlayer === null)
			return;
		target.audioPlayer.playSound(soundId);
	}
}

function sound_playuntildone({SOUND_MENU}){
	const {runtime, target} = this.userData;
	const index = _getSoundIndex.call(this, SOUND_MENU);
	if(index >= 0){
		const soundId = target.sprite.sounds[index].soundId;
		if(target.audioPlayer === null)
			return;
		return target.audioPlayer.playSound(soundId);
	}
}

function _getSoundIndex(soundName){
	const {runtime, target} = this.userData;
	// if the sprite has no sounds, return -1
	const len = target.sprite.sounds.length;
	if(len === 0){
		return -1;
	}

	// look up by name first
	const index = getSoundIndexByName.call(this, soundName);
	if (index !== -1) {
		return index;
	}

	// then try using the sound name as a 1-indexed index
	const oneIndexedIndex = parseInt(soundName, 10);
	if (!isNaN(oneIndexedIndex)) {
		return MathUtil.wrapClamp(oneIndexedIndex - 1, 0, len - 1);
	}

	// could not be found as a name or converted to index, return -1
	return -1;
}

function getSoundIndexByName(soundName){
	const {runtime, target} = this.userData;
	const sounds = target.sprite.sounds;
	for (let i = 0; i < sounds.length; i++) {
		if (sounds[i].name === soundName) {
			return i;
		}
	}
	// if there is no sound by that name, return -1
	return -1;
}

function sound_stopallsounds(){
	const {runtime, target} = this.userData;
	if(target.audioPlayer === null)
		return;
	target.audioPlayer.stopAllSounds();
}

function sound_playnoteforbeats({NOTE, BEATS}){
	const {runtime, target} = this.userData;
	let note = Cast.toNumber(NOTE);
	note = MathUtil.clamp(note, MIDI_NOTE_RANGE.min, MIDI_NOTE_RANGE.max);
	let beats = Cast.toNumber(BEATS);
	beats = _clampBeats(beats);
	const soundState = _getSoundState(target);
	const inst = soundState.currentInstrument;
	const vol = soundState.volume;
	if (typeof runtime.audioEngine === 'undefined') return;
	return runtime.audioEngine.playNoteForBeatsWithInstAndVol(note, beats, inst, vol);
}

function sound_playdrumforbeats({DRUM, BEATS}){
	const {runtime, target} = this.userData;
	let drum = Cast.toNumber(DRUM);
	drum -= 1; // drums are one-indexed
	if (typeof runtime.audioEngine === 'undefined') return;
	drum = MathUtil.wrapClamp(drum, 0, runtime.audioEngine.numDrums - 1);
	let beats = Cast.toNumber(BEATS);
	beats = _clampBeats(beats);
	if (target.audioPlayer === null) return;
	return target.audioPlayer.playDrumForBeats(drum, beats);
}

function sound_restforbeats({BEATS}){
	const {runtime, target} = this.userData;
	const beats = _clampBeats(Cast.toNumber(BEATS));
	if (typeof runtime.audioEngine === 'undefined') return;
	return runtime.audioEngine.waitForBeats(beats);
}

function _clampBeats(beats){
	return MathUtil.clamp(beats, BEAT_RANGE.min, BEAT_RANGE.max);
}

function sound_setinstrumentto({INSTRUMENT}){
	const {runtime, target} = this.userData;
	const soundState = _getSoundState(target);
	let instNum = Cast.toNumber(INSTRUMENT);
	instNum -= 1; // instruments are one-indexed
	if (typeof runtime.audioEngine === 'undefined') return;
	instNum = MathUtil.wrapClamp(instNum, 0, runtime.audioEngine.numInstruments - 1);
	soundState.currentInstrument = instNum;
	return runtime.audioEngine.instrumentPlayer.loadInstrument(soundState.currentInstrument);
}

function sound_seteffectto(args){
	_updateEffect.call(this, args, false);
}

function sound_changeeffectby(args){
	_updateEffect.call(this, args, true);
}

function _updateEffect(args, change){
	const {runtime, target} = this.userData;
	const effect = Cast.toString(args.EFFECT).toLowerCase();
	const value = Cast.toNumber(args.VALUE);

	const soundState = _getSoundState(target);
	if(!soundState.effects.hasOwnProperty(effect))
		return;

	if(change){
		soundState.effects[effect] += value;
	}else{
		soundState.effects[effect] = value;
	}

	const effectRange = EFFECT_RANGE[effect];
	soundState.effects[effect] = MathUtil.clamp(soundState.effects[effect], effectRange.min, effectRange.max);

	if(target.audioPlayer)
		target.audioPlayer.setEffect(effect, soundState.effects[effect]);
}

function sound_cleareffects(args, util){
	const {runtime, target} = this.userData;
	const soundState = _getSoundState(target);
	for(const effect in soundState.effects){
		if(!soundState.effects.hasOwnProperty(effect))
			continue;
		soundState.effects[effect] = 0;
	}
	if(target.audioPlayer)
		target.audioPlayer.clearEffects();
}

function sound_setvolumeto({VOLUME}){
	const {runtime, target} = this.userData;
	_updateVolume(Cast.toNumber(VOLUME), target);
}

function sound_changevolumeby({VOLUME}){
	const {runtime, target} = this.userData;
	const soundState = _getSoundState(target);
	const volume = Cast.toNumber(VOLUME) + soundState.volume;
	this._updateVolume(volume, target);
}

function _updateVolume(volume, target){
	const soundState = _getSoundState(target);
	volume = MathUtil.clamp(volume, 0, 100);
	soundState.volume = volume;
	if(target.audioPlayer)
		target.audioPlayer.setVolume(soundState.volume);
}

function sound_volume(args, util){
	const {runtime, target} = this.userData;
	const soundState = _getSoundState(target);
	return soundState.volume;
}

function sound_settempotobpm({TEMPO}){
	const {runtime, target} = this.userData;
	_updateTempo(runtime.audioEngine, Cast.toNumber(TEMPO));
}

function sound_changetempoby({TEMPO}){
	const {runtime, target} = this.userData;
	const audioEngine = runtime.audioEngine;
	if(audioEngine){
		_updateTempo(audioEngine, audioEngine.currentTempo + Cast.toNumber(TEMPO));
	}
}

function _updateTempo(audioEngine, tempo){
	if(audioEngine){
		audioEngine.setTempo(MathUtil.clamp(tempo, TEMPO_RANGE.min, TEMPO_RANGE.max));
	}
}

function sound_tempo(){
	const {runtime, target} = this.userData;
	if(runtime.audioEngine){
		return runtime.audioEngine.currentTempo;
	}
}
/*
function soundsMenu(args){
	return args.SOUND_MENU;
}

function beatsMenu(args){
	return args.BEATS;
}

function effectsMenu(args){
	return args.EFFECT;
}
*/
module.exports = {
	sound_play,
	sound_playuntildone,
	sound_stopallsounds,
	sound_playnoteforbeats,
	sound_playdrumforbeats,
	sound_restforbeats,
	sound_setinstrumentto,
	sound_seteffectto,
	sound_changeeffectby,
	sound_cleareffects,
	sound_setvolumeto,
	sound_changevolumeby,
	sound_volume,
	sound_settempotobpm,
	sound_changetempoby,
	sound_tempo
};
