const Cast = require('../util/cast');
const MathUtil = require('../util/math-util');

function getTargetXY(targetName){
	const {runtime} = this.userData;
	const device = runtime.ioDevices['mouse'];
	let targetX = 0;
	let targetY = 0;
	if (targetName === '_mouse_'){
		targetX = device.getX();
		targetY = device.getY();
	}else if(targetName === '_random_'){
		const stageWidth = runtime.constructor.STAGE_WIDTH;
		const stageHeight = runtime.constructor.STAGE_HEIGHT;
		targetX = Math.round(stageWidth * (Math.random() - 0.5));
		targetY = Math.round(stageHeight * (Math.random() - 0.5));
	} else {
		const goToTarget = runtime.getSpriteTargetByName(targetName);
		if(!goToTarget)
			return;
		targetX = goToTarget.x;
		targetY = goToTarget.y;
	}
	return [targetX, targetY];
}

function motion_movesteps({STEPS}){
	const {runtime, target} = this.userData;
	STEPS = Cast.toNumber(STEPS);
	const radians = MathUtil.degToRad(90 - target.direction);
	const dx = steps * Math.cos(radians);
	const dy = steps * Math.sin(radians);
	target.setXY(target.x + dx, target.y + dy);
}

function motion_gotoxy({X, Y}){
	const {runtime, target} = this.userData;
	target.setXY(Cast.toNumber(X), Cast.toNumber(Y));
}

function motion_goto({TO}){
	const {runtime, target} = this.userData;
	const targetXY = getTargetXY.call(this, TO);
	if(targetXY){
		target.setXY(...targetXY);
	}
}

function motion_turnright({DEGREES}){
	const {runtime, target} = this.userData;
	target.setDirection(target.direction + Cast.toNumber(DEGREES));
}

function motion_turnleft({DEGREES}){
	const {runtime, target} = this.userData;
	target.setDirection(target.direction - Cast.toNumber(DEGREES));
}

function motion_pointindirection({DIRECTION}){
	const {runtime, target} = this.userData;
	target.setDirection(Cast.toNumber(DIRECTION));
}

function motion_pointtowards({TOWARDS}){
	const {runtime, target} = this.userData;
	const targetXY = getTargetXY.call(this, TOWARDS);
	if(targetXY){
		const dx = targetXY[0] - target.x;
		const dy = targetXY[1] - target.y;
		const direction = 90 - MathUtil.radToDeg(Math.atan2(dy, dx));
		target.setDirection(direction);
	}
}

function motion_glidesecstoxy({SECS, X, Y}){
	const {runtime, target} = this.userData;
	const duration = Cast.toNumber(SECS) * 1000;
	const beginTime = performance.now();
	const startX = target.x;
	const startY = target.y;
	const endX = Cast.toNumber(X);
	const endY = Cast.toNumber(Y);

	if(duration <= 0){
		target.setXY(endX, endY);
		return;
	}
	return new Promise(resolve => {
		this.suspendUpdater = () => {
			const timeElapsed = performance.now() - beginTime;
			if(timeElapsed >= duration){
				target.setXY(endX, endY);
				resolve();
			}else{
				const frac = timeElapsed / duration;
				const dx = frac * (endX - startX);
				const dy = frac * (endY - startY);
				target.setXY(startX + dx, startY + dy);
			}
		};
	});
}

function motion_glideto({SECS, TO}){
	const {runtime, target} = this.userData;
	const targetXY = getTargetXY.call(this, TO);
	if(targetXY){
		return motion_glidesecstoxy.call(this, {SECS, X: targetXY[0], Y: targetXY[1]});
	}
}

function motion_ifonedgebounce(){
	const {runtime, target} = this.userData;
	const bounds = target.getBounds();
	if(!bounds){
		return;
	}
	// Measure distance to edges.
	// Values are positive when the sprite is far away,
	// and clamped to zero when the sprite is beyond.
	const stageWidth = runtime.constructor.STAGE_WIDTH;
	const stageHeight = runtime.constructor.STAGE_HEIGHT;
	const distLeft = Math.max(0, (stageWidth / 2) + bounds.left);
	const distTop = Math.max(0, (stageHeight / 2) - bounds.top);
	const distRight = Math.max(0, (stageWidth / 2) - bounds.right);
	const distBottom = Math.max(0, (stageHeight / 2) + bounds.bottom);
	// Find the nearest edge.
	let nearestEdge = '';
	let minDist = Infinity;
	if(distLeft < minDist){
		minDist = distLeft;
		nearestEdge = 'left';
	}
	if(distTop < minDist){
		minDist = distTop;
		nearestEdge = 'top';
	}
	if(distRight < minDist){
		minDist = distRight;
		nearestEdge = 'right';
	}
	if(distBottom < minDist){
		minDist = distBottom;
		nearestEdge = 'bottom';
	}
	if(minDist > 0){
		return; // Not touching any edge.
	}
	// Point away from the nearest edge.
	const radians = MathUtil.degToRad(90 - target.direction);
	let dx = Math.cos(radians);
	let dy = -Math.sin(radians);
	if(nearestEdge === 'left'){
		dx = Math.max(0.2, Math.abs(dx));
	}else if(nearestEdge === 'top'){
		dy = Math.max(0.2, Math.abs(dy));
	}else if(nearestEdge === 'right'){
		dx = -Math.max(0.2, Math.abs(dx));
	}else if(nearestEdge === 'bottom'){
		dy = -Math.max(0.2, Math.abs(dy));
	}
	const newDirection = MathUtil.radToDeg(Math.atan2(dy, dx)) + 90;
	target.setDirection(newDirection);
	// Keep within the stage.
	const fencedPosition = target.keepInFence(target.x, target.y);
	target.setXY(fencedPosition[0], fencedPosition[1]);
}

function motion_setrotationstyle({STYLE}){
	const {runtime, target} = this.userData;
	target.setRotationStyle(STYLE);
}

function motion_changexby({DX}){
	const {runtime, target} = this.userData;
	target.setXY(target.x + Cast.toNumber(DX), target.y);
}

function motion_changeyby({DY}){
	const {runtime, target} = this.userData;
	target.setXY(target.x, target.y + Cast.toNumber(DY));
}

function motion_setx({X}){
	const {runtime, target} = this.userData;
	target.setXY(Cast.toNumber(X), target.y);
}

function motion_sety({Y}){
	const {runtime, target} = this.userData;
	target.setXY(target.x, Cast.toNumber(Y));
}

function motion_xposition(){
	const {runtime, target} = this.userData;
	return target.x;
}

function motion_yposition(){
	const {runtime, target} = this.userData;
	return target.y;
}

function motion_direction(){
	const {runtime, target} = this.userData;
	return target.direction;
}

module.exports = {
	motion_movesteps,
	motion_gotoxy,
	motion_goto,
	motion_turnright,
	motion_turnleft,
	motion_pointindirection,
	motion_pointtowards,
	motion_ifonedgebounce,
	motion_setrotationstyle,
	motion_changexby,
	motion_changeyby,
	motion_setx,
	motion_sety,
	motion_xposition,
	motion_yposition,
	motion_direction,
	motion_glidesecstoxy,
	motion_glideto
};