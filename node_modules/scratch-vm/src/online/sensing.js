const Cast = require('../util/cast');
const MathUtil = require('../util/math-util');

function sensing_touchingobject({TOUCHINGOBJECTMENU}){
	const {runtime, target} = this.userData;
	switch(TOUCHINGOBJECTMENU){
	case '_mouse_':
		let device = runtime.ioDevices['mouse'];
		return target.isTouchingPoint(device.getX(), device.getY());
	case '_edge_':
		return target.isTouchingEdge();
	}
	return target.isTouchingSprite(TOUCHINGOBJECTMENU);
}

function sensing_touchingcolor({COLOR}){
	const {runtime, target} = this.userData;
	return target.isTouchingColor(Cast.toRgbColorList(COLOR));
}

function sensing_coloristouchingcolor({COLOR, COLOR2}){
	const {runtime, target} = this.userData;
	const maskColor = Cast.toRgbColorList(COLOR);
	const targetColor = Cast.toRgbColorList(COLOR2);
	return target.colorIsTouchingColor(targetColor, maskColor);
}

function sensing_distanceto({DISTANCETOMENU}){
	const {runtime, target} = this.userData;
	if(target.isStage)
		return 10000;
	let targetX = 0;
	let targetY = 0;
	if(DISTANCETOMENU === '_mouse_'){
		let device = runtime.ioDevices['mouse'];
		targetX = device.getX();
		targetY = device.getY();
	}else{
		const distTarget = runtime.getSpriteTargetByName(DISTANCETOMENU);
		if(!distTarget)
			return 10000;
		targetX = distTarget.x;
		targetY = distTarget.y;
	}
	const dx = target.x - targetX;
	const dy = target.y - targetY;
	return Math.sqrt((dx * dx) + (dy * dy));
}

let timestamp;

function sensing_timer(){
	return 0.001 * (performance.now() - timestamp);
}

function sensing_resettimer(){
	timestamp = performance.now();
}

sensing_resettimer();

function sensing_of({OBJECT, PROPERTY}){
	const {runtime} = this.userData;
	let attrTarget;

	if(args.OBJECT === '_stage_'){
		attrTarget = runtime.getTargetForStage();
	}else{
		attrTarget = runtime.getSpriteTargetByName(OBJECT);
	}
	// Generic attributes
	if(attrTarget.isStage){
		switch(PROPERTY){
		// Scratch 1.4 support
		case 'background #':  return attrTarget.currentCostume + 1;
		case 'backdrop #':    return attrTarget.currentCostume + 1;
		case 'backdrop name': return attrTarget.sprite.costumes[attrTarget.currentCostume].name;
		case 'volume':        return 0; // @todo: Keep this in mind for sound blocks!
		}
	}else{
		switch(PROPERTY){
		case 'x position':   return attrTarget.x;
		case 'y position':   return attrTarget.y;
		case 'direction':    return attrTarget.direction;
		case 'costume #':    return attrTarget.currentCostume + 1;
		case 'costume name': return attrTarget.sprite.costumes[attrTarget.currentCostume].name;
		case 'size':         return attrTarget.size;
		case 'volume':       return 0; // @todo: above, keep in mind for sound blocks..
		}
	}
	// Variables
	if(attrTarget.variables.hasOwnProperty(PROPERTY)){
		return attrTarget.variables[PROPERTY].value;
	}
	// Otherwise, 0
	return 0;
}

function sensing_mousex(){
	const {runtime, target} = this.userData;
	let device = runtime.ioDevices['mouse'];
	return device.getX();
}

function sensing_mousey(){
	const {runtime, target} = this.userData;
	let device = runtime.ioDevices['mouse'];
	return device.getY();
}

function sensing_mousedown(){
	const {runtime, target} = this.userData;
	let device = runtime.ioDevices['mouse'];
	return device.getIsDown();
}

function sensing_keypressed({KEY_OPTION}){
	const {runtime, target} = this.userData;
	let device = runtime.ioDevices['keyboard'];
	return device.getKeyIsDown(KEY_OPTION);
}

function sensing_current({CURRENTMENU}){
	const date = new Date();
	switch(Cast.toString(CURRENTMENU).toLowerCase()){
	case 'year':      return date.getFullYear();
	case 'month':     return date.getMonth() + 1; // getMonth is zero-based
	case 'date':      return date.getDate();
	case 'dayofweek': return date.getDay() + 1; // getDay is zero-based, Sun=0
	case 'hour':      return date.getHours();
	case 'minute':    return date.getMinutes();
	case 'second':    return date.getSeconds();
	}
	return 0;
}

function sensing_dayssince2000(){
	const msPerDay = 24 * 60 * 60 * 1000;
	const start = new Date(2000, 0, 1); // Months are 0-indexed.
	const today = new Date();
	const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
	let mSecsSinceStart = today.valueOf() - start.valueOf();
	mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);
	return mSecsSinceStart / msPerDay;
}

function sensing_loudness(){
	const {runtime, target} = this.userData;
	if(runtime.audioEngine){
		return runtime.audioEngine.getLoudness();
	}
	return -1;
}

module.exports = {
	sensing_touchingobject,
	sensing_touchingcolor,
	sensing_coloristouchingcolor,
	sensing_distanceto,
	sensing_timer,
	sensing_resettimer,
	sensing_of,
	sensing_mousex,
	sensing_mousey,
	sensing_mousedown,
	sensing_keypressed,
	sensing_current,
	sensing_dayssince2000,
	sensing_loudness
};

