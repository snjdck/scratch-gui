const Cast = require('../util/cast');

function control_wait({DURATION}){
	const seconds = Cast.toNumber(DURATION);
	const timeout = performance.now() + seconds * 1000;
	return new Promise(resolve => {
		this.suspendUpdater = () => {
			if(performance.now() >= timeout){
				resolve();
			}
		};
	});
}

function control_stop({STOP_OPTION}){
	const {runtime, target} = this.userData;
	switch(STOP_OPTION){
	case 'all':
		runtime.stopAll();
		break;
	case 'other scripts in sprite':
	case 'other scripts in stage':
		runtime.stopForTarget(target, this);
		break;
	case 'this script':
		this.interrupt();
		break;
	}
}

function control_create_clone_of({CLONE_OPTION}){
	const {runtime, target} = this.userData;
	let cloneTarget;
	if(CLONE_OPTION === '_myself_'){
		cloneTarget = target;
	}else{
		cloneTarget = runtime.getSpriteTargetByName(CLONE_OPTION);
	}
	if(!cloneTarget){
		return;
	}
	const newClone = cloneTarget.makeClone();
	if(newClone){
		runtime.targets.push(newClone);
	}
}

function control_delete_this_clone(){
	const {runtime, target} = this.userData;
	if(target.isOriginal)
		return;
	runtime.disposeTarget(target);
	runtime.stopForTarget(target);
}

module.exports = {
	control_wait,
	control_stop,
	control_create_clone_of,
	control_delete_this_clone
};